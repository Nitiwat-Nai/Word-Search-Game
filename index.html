<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search</title>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* --- THEME & GLOBAL STYLES --- */
        :root {
            --color-primary-found: #38C172; /* Bright Green - For Found Word */
            --color-secondary-select: #42A5F5; /* Blue - For Selection */
            --color-wrong: #EF5350; /* Red - For Incorrect Flash */
            --color-bg: #80DEEA; /* Light Cyan/Aqua Background */
            --color-card: #FFFFFF; /* White Card/Container */
            --color-text-dark: #2C3E50; /* Dark Text */
            --color-text-light: #FFFFFF;
            --color-header: #29B6F6; /* Brighter Blue Header */
            --color-grid-line: #BBDEFB; /* Light Blue Grid Separator */

            --found-color: var(--color-primary-found); 
        }

        /* Responsive Container */
        body {
            font-family: 'Sarabun', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text-dark);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            text-align: center;
        }

        .container {
            width: 100%;
            max-width: 500px; 
            box-sizing: border-box;
            background-color: var(--color-card);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding: 0;
        }

        /* Header */
        header {
            background-color: var(--color-header); 
            color: var(--color-text-light);
            padding: 1.5rem 1rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
            margin-bottom: 1rem;
        }
        header h1 {
            font-size: 1.8rem;
            margin: 0;
        }

        /* Status Bar */
        #status-bar {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            margin-bottom: 1rem;
            padding: 0 1rem;
            color: var(--color-text-dark);
        }

        /* --- GAME SPECIFIC STYLES --- */
        #game-area {
            display: flex;
            flex-direction: column; 
            padding: 0 1rem 1rem;
            gap: 1rem;
        }

        /* --- Grid (The Search Area) --- */
        #word-search-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr); 
            width: 100%;
            max-width: 480px; 
            margin: 0 auto;
            border: 2px solid var(--color-grid-line);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
            user-select: none; 
            touch-action: manipulation; 
        }

        .grid-cell {
            aspect-ratio: 1 / 1; 
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
            color: var(--color-text-dark);
            border: 1px solid var(--color-grid-line);
            box-sizing: border-box;
            transition: background-color 0.1s, color 0.1s, transform 0.1s;
        }

        /* Selection States */
        .grid-cell.selected {
            background-color: var(--color-secondary-select);
            color: var(--color-text-light);
            transform: scale(1.05); 
            z-index: 10;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* Found State (Permanent Green) */
        .grid-cell.found {
            background-color: var(--found-color);
            color: var(--color-text-light); 
            font-weight: 900;
            border-color: var(--found-color);
        }
        
        /* Wrong Guess Flash (Red) */
        .grid-cell.wrong-flash {
            background-color: var(--color-wrong);
            color: var(--color-text-light) !important;
            animation: wrongFlash 1s ease-out; 
        }
        
        @keyframes wrongFlash {
            0% { background-color: var(--color-wrong); }
            50% { background-color: var(--color-wrong); }
            100% { background-color: inherit; color: inherit; } 
        }

        /* --- Clues Area (The List) --- */
        #clue-panel {
            text-align: left;
            background-color: #F0F4C3; 
            padding: 15px;
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
        }
        #clue-panel h3 {
            margin-top: 0;
            color: var(--color-text-dark);
            font-size: 1.3rem;
            border-bottom: 2px solid #C5E1A5;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        #clue-list {
            list-style: none;
            padding: 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); 
            gap: 10px;
        }
        .clue-item {
            background-color: #E0E0E0; 
            padding: 10px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--color-text-dark);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .clue-item.found {
            background-color: var(--found-color); 
            color: var(--color-text-light);
            opacity: 1;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            font-size: 1.1rem; 
            transition: all 0.3s;
        }
        
        .clue-hint {
            display: block;
            font-size: 0.8rem;
            font-weight: 400;
            color: #757575; 
            margin-top: 5px;
        }
        
        .clue-word-text {
            display: none; 
            font-weight: 900;
            font-size: 1.2rem;
            text-transform: uppercase;
        }
        
        .clue-item.found .clue-hint {
            display: none;
        }
        .clue-item.found .clue-word-text {
            display: block;
            color: var(--color-text-light); 
        }
        
        /* Generic Button Style */
        .main-btn {
            background-color: var(--color-secondary-select);
            color: var(--color-text-light);
            border: none;
            padding: 1rem;
            border-radius: 12px;
            font-size: 1.3rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 0 #3188d6;
            transition: transform 0.1s, box-shadow 0.1s;
            width: 100%;
            margin-top: 1rem;
        }
        .main-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #3188d6;
        }
        .main-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>Word Search</h1>
        </header>

        <div id="status-bar">
            <span id="category-title">‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà: ‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏õ‡πà‡∏≤ (Animals)</span>
            <span id="score">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏ó‡∏µ‡πà‡∏û‡∏ö: 0/10</span>
        </div>

        <div id="game-area">
            <div id="word-search-grid">
                </div>

            <div id="clue-panel">
                <h3>‡∏Ñ‡∏≥‡πÉ‡∏ö‡πâ (Thai Clues)</h3>
                <p style="font-size: 0.9rem; color: #5D4037;">*‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏•‡∏¥‡∏Å‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå*</p>
                <ul id="clue-list">
                    </ul>
            </div>
            
            <button id="restart-btn" class="main-btn">
                ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà
            </button>
        </div>
    </div>

    <script>
        let audioContext;
        let voices = [];
        
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function setupSpeech() {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.onvoiceschanged = () => {
                    voices = window.speechSynthesis.getVoices();
                };
            }
        }
        
        function getVoice(lang) {
             return voices.find(v => v.lang.startsWith(lang)) || voices.find(v => v.lang.startsWith(lang.substring(0, 2))) || null;
        }

        function speakText(text, lang) {
            if (!('speechSynthesis' in window)) return;

            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = lang;
            utterance.rate = (lang === 'en-US') ? 0.8 : 0.9; 
            utterance.volume = 1;

            const targetVoice = (lang === 'en-US') ? getVoice('en-US') : getVoice('th-TH');
            if (targetVoice) {
                utterance.voice = targetVoice;
            }

            window.speechSynthesis.speak(utterance);
        }

        function createTone(frequency, duration, type, volume = 0.5) {
            initAudioContext();
            if (!audioContext || audioContext.state === 'suspended') return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type; 

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playSuccessTone() { createTone(660, 0.15, 'sine', 0.8); }
        function playFailTone() { createTone(150, 0.4, 'triangle', 0.7); }
    </script>

    <script>
        // --- DATA ---
        const GRID_SIZE = 10;
        const targetWords = [
            { word: "TIGER", clue: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏•‡πÅ‡∏°‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏™‡∏µ‡∏î‡∏≥‡∏ö‡∏ô‡∏Ç‡∏ô‡∏™‡∏µ‡∏™‡πâ‡∏°", found: false },
            { word: "LION", clue: "‡∏£‡∏≤‡∏ä‡∏≤‡πÅ‡∏´‡πà‡∏á‡∏õ‡πà‡∏≤ ‡∏°‡∏µ‡πÅ‡∏ú‡∏á‡∏Ñ‡∏≠‡πÉ‡∏´‡∏ç‡πà", found: false },
            { word: "ZEBRA", clue: "‡∏°‡πâ‡∏≤‡∏•‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏™‡∏µ‡∏î‡∏≥‡πÅ‡∏•‡∏∞‡∏Ç‡∏≤‡∏ß", found: false },
            { word: "FOX", clue: "‡∏™‡∏∏‡∏ô‡∏±‡∏Ç‡∏à‡∏¥‡πâ‡∏á‡∏à‡∏≠‡∏Å ‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏à‡πâ‡∏≤‡πÄ‡∏•‡πà‡∏´‡πå", found: false },
            { word: "DEER", clue: "‡∏Å‡∏ß‡∏≤‡∏á ‡∏°‡∏µ‡πÄ‡∏Ç‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°", found: false },
            { word: "BEAR", clue: "‡∏´‡∏°‡∏µ ‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏µ‡πà‡∏ä‡∏≠‡∏ö‡∏Å‡∏¥‡∏ô‡∏ô‡πâ‡∏≥‡∏ú‡∏∂‡πâ‡∏á", found: false },
            { word: "WOLF", clue: "‡∏´‡∏°‡∏≤‡∏õ‡πà‡∏≤ ‡∏°‡∏±‡∏Å‡∏•‡πà‡∏≤‡πÄ‡∏´‡∏¢‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏ù‡∏π‡∏á", found: false },
            { word: "EAGLE", clue: "‡∏ô‡∏Å‡∏≠‡∏¥‡∏ô‡∏ó‡∏£‡∏µ ‡∏ô‡∏Å‡∏•‡πà‡∏≤‡πÄ‡∏´‡∏¢‡∏∑‡πà‡∏≠‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà", found: false },
            { word: "SNAKE", clue: "‡∏™‡∏±‡∏ï‡∏ß‡πå‡πÄ‡∏•‡∏∑‡πâ‡∏≠‡∏¢‡∏Ñ‡∏•‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡∏≤", found: false },
            { word: "CUB", clue: "‡∏•‡∏π‡∏Å‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏Å‡∏¥‡∏ô‡πÄ‡∏ô‡∏∑‡πâ‡∏≠ ‡πÄ‡∏ä‡πà‡∏ô ‡∏•‡∏π‡∏Å‡∏´‡∏°‡∏µ ‡∏•‡∏π‡∏Å‡∏™‡∏¥‡∏á‡πÇ‡∏ï", found: false },
        ].map(item => ({ ...item, word: item.word.toUpperCase() }));

        const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

        // --- GAME STATE ---
        let grid = [];
        let placedWordsMeta = []; 
        let startCell = null; 
        let selectedCells = []; 
        
        // --- ELEMENTS ---
        const gridEl = document.getElementById('word-search-grid');
        const clueListEl = document.getElementById('clue-list');
        const scoreEl = document.getElementById('score');
        const restartBtn = document.getElementById('restart-btn');


        // --- UTILS (Word Placement and Grid Functions) ---
        function createEmptyGrid() { grid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill('')); }
        function getRandomLetter() { return ALPHABET[Math.floor(Math.random() * ALPHABET.length)]; }
        function isSafe(r, c, len, direction) {
            const [dr, dc] = direction;
            if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE) return false;
            const newR = r + (len - 1) * dr;
            const newC = c + (len - 1) * dc;
            return newR >= 0 && newR < GRID_SIZE && newC >= 0 && newC < GRID_SIZE;
        }
        function checkWordFit(r, c, word, direction) {
            const [dr, dc] = direction;
            const len = word.length;
            if (!isSafe(r, c, len, direction)) return false;

            for (let i = 0; i < len; i++) {
                const char = grid[r + i * dr][c + i * dc];
                if (char !== '' && char !== word[i]) {
                    return false;
                }
            }
            return true;
        }
        function placeWord(r, c, word, direction) {
            const [dr, dc] = direction;
            for (let i = 0; i < word.length; i++) {
                grid[r + i * dr][c + i * dc] = word[i];
            }
        }
        function generatePuzzle() {
            createEmptyGrid();
            const directions = [ [0, 1], [1, 0], [1, 1], [-1, 0], [0, -1], [-1, -1], [1, -1], [-1, 1] ];
            placedWordsMeta = [];
            const placementWords = [...targetWords].sort(() => Math.random() - 0.5); 
            
            placementWords.forEach(wordObj => {
                const word = wordObj.word;
                let placed = false;
                let attempts = 0;

                while (!placed && attempts < 200) { 
                    const r = Math.floor(Math.random() * GRID_SIZE);
                    const c = Math.floor(Math.random() * GRID_SIZE);
                    const direction = directions[Math.floor(Math.random() * directions.length)];

                    if (checkWordFit(r, c, word, direction)) {
                        placeWord(r, c, word, direction);
                        placedWordsMeta.push({ 
                            word: word, 
                            start: { r: r, c: c }, 
                            end: { r: r + (word.length - 1) * direction[0], c: c + (word.length - 1) * direction[1] } 
                        });
                        placed = true;
                    }
                    attempts++;
                }
            });

            // Fill Empty Cells
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = getRandomLetter();
                    }
                }
            }
        }
        function getCellsInLine(r1, c1, r2, c2) {
            const cells = [];
            const dr = Math.sign(r2 - r1);
            const dc = Math.sign(c2 - c1);
            
            const isHorizontal = r1 === r2 && c1 !== c2;
            const isVertical = c1 === c2 && r1 !== r2;
            const isDiagonal = Math.abs(r1 - r2) === Math.abs(c1 - c2) && r1 !== r2;
            
            if (r1 === r2 && c1 === c2) { // Single cell selection (Only Start Cell)
                 const cellEl = gridEl.querySelector(`[data-row="${r1}"][data-col="${c1}"]`);
                 if (cellEl) cells.push(cellEl);
                 return cells;
            }
            
            if (!isHorizontal && !isVertical && !isDiagonal) return [];

            let r = r1;
            let c = c1;

            while (true) {
                const cellEl = gridEl.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (cellEl) cells.push(cellEl);

                if (r === r2 && c === c2) break;
                
                r += dr;
                c += dc;

                if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE) break;
            }
            return cells;
        }

        // --- CORE LOGIC (Selection, Check, Mark) ---

        function clearSelection(flash = false) {
            selectedCells.forEach(cell => {
                cell.classList.remove('selected'); 
                
                if (flash) {
                    cell.classList.add('wrong-flash');
                    setTimeout(() => {
                        cell.classList.remove('wrong-flash');
                        cell.style.transform = 'scale(1)'; 
                    }, 1000);
                } else {
                    cell.style.transform = 'scale(1)'; 
                }
            });
            
            // Reset State for the next selection cycle
            selectedCells = [];
            startCell = null;
        }
        
        function handleWordCheck() {
            // Check requires at least 2 cells to be selected
            if (selectedCells.length < 2) {
                clearSelection(false);
                return;
            }
            
            const selectedWord = selectedCells.map(cell => cell.textContent).join('');

            let foundIndex = -1;

            targetWords.forEach((wordObj, index) => {
                // IMPORTANT: We only check words that haven't been found yet
                if (wordObj.found) return;

                const target = wordObj.word;
                const reversedTarget = target.split('').reverse().join('');

                if (selectedWord === target || selectedWord === reversedTarget) {
                    foundIndex = index;
                }
            });

            if (foundIndex !== -1) {
                markAsFound(foundIndex, selectedCells, targetWords[foundIndex]);
            } else {
                playFailTone();
                clearSelection(true); // Incorrect Word: Flash Red and Clear
            }
        }

        function markAsFound(index, cells, wordDetails) {
            targetWords[index].found = true;
            
            cells.forEach(cell => {
                cell.classList.remove('selected', 'wrong-flash');
                cell.classList.add('found');
                cell.style.transform = 'scale(1)'; 
            });

            const clueEl = clueListEl.querySelector(`[data-index="${index}"]`);
            if (clueEl) {
                clueEl.classList.add('found');
            }
            
            playSuccessTone();
            
            // FIX #2: Read only the English word, not the Thai clue.
            speakText(wordDetails.word, 'en-US'); 
            
            checkWinCondition();
            
            selectedCells = [];
            startCell = null;
        }


        // --- CLICK SELECTION HANDLER (START/END) ---
        function onCellClick(e) {
            const cell = e.target;
            
            // FIX #1: Removed 'cell.classList.contains("found")' check.
            // Now players can click cells that are already part of a found word.
            if (!cell.classList.contains('grid-cell')) return; 

            if (startCell === null) {
                // First click: Set Start Cell
                clearSelection(false); 
                startCell = cell;
                startCell.classList.add('selected');
                selectedCells = [startCell];
            } else {
                // Second click: Set End Cell, Check Line, and Auto-Check Word
                const endCell = cell; 
                
                // If the user clicks the start cell again, clear the selection
                if (startCell === endCell) {
                    clearSelection(false);
                    return;
                }

                const r1 = parseInt(startCell.dataset.row);
                const c1 = parseInt(startCell.dataset.col);
                const r2 = parseInt(endCell.dataset.row);
                const c2 = parseInt(endCell.dataset.col);
                
                const isHorizontal = r1 === r2;
                const isVertical = c1 === c2;
                const isDiagonal = Math.abs(r1 - r2) === Math.abs(c1 - c2);

                if (isHorizontal || isVertical || isDiagonal) {
                    // Valid Line: Highlight the full path
                    selectedCells.forEach(c => c.classList.remove('selected'));
                    selectedCells = getCellsInLine(r1, c1, r2, c2);
                    selectedCells.forEach(c => c.classList.add('selected'));
                    
                    // Auto-check the word
                    handleWordCheck();
                } else {
                    // Invalid Line: Flash the start and end cell, then clear
                    selectedCells.forEach(c => c.classList.remove('selected'));
                    startCell.classList.add('selected');
                    endCell.classList.add('selected');
                    selectedCells = [startCell, endCell]; 
                    
                    playFailTone();
                    clearSelection(true); 
                }
            }
        }
        
        function attachGridListeners() {
            gridEl.addEventListener('click', onCellClick);
        }
        
        // --- RENDERING & UI UPDATES ---
        function renderGrid() {
            gridEl.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = grid[r][c];
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gridEl.appendChild(cell);
                }
            }
        }

        function renderClues() {
            clueListEl.innerHTML = '';
            targetWords.forEach((wordObj, index) => {
                const li = document.createElement('li');
                li.className = 'clue-item' + (wordObj.found ? ' found' : '');
                li.dataset.index = index;
                
                const hintSpan = document.createElement('span');
                hintSpan.className = 'clue-hint';
                hintSpan.textContent = wordObj.clue;
                
                const wordSpan = document.createElement('span');
                wordSpan.className = 'clue-word-text';
                wordSpan.textContent = wordObj.word;
                
                li.appendChild(wordSpan);
                li.appendChild(hintSpan);
                clueListEl.appendChild(li);
            });
            checkWinCondition();
        }
        
        function checkWinCondition() {
            const foundCount = targetWords.filter(w => w.found).length;
            scoreEl.textContent = `‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏ó‡∏µ‡πà‡∏û‡∏ö: ${foundCount}/${targetWords.length}`;
            if (foundCount === targetWords.length) {
                alert("üéâ ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏î‡πâ‡∏ß‡∏¢! ‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÑ‡∏î‡πâ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏≥‡πÅ‡∏•‡πâ‡∏ß!");
                restartBtn.textContent = "‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà!";
            }
        }


        // --- INITIALIZATION ---
        function init() {
            targetWords.forEach(w => w.found = false);
            
            generatePuzzle();
            renderGrid();
            renderClues();
            
            // Attach listeners only once
            if (!gridEl.dataset.listenersAttached) {
                attachGridListeners(); 
                gridEl.dataset.listenersAttached = 'true';
            }
            
            clearSelection(false);
            restartBtn.textContent = "‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà";
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            setupSpeech();
            document.addEventListener('click', () => {
                initAudioContext();
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }, { once: true });
            
            init(); 
        });
        
        restartBtn.addEventListener('click', init);
        
    </script>
</body>
</html>
